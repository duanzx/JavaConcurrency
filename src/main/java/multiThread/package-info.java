package multiThread;
/**
 * 主要介绍多线程的系统架构设计，使用合适的设计方法可以提高系统的吞吐量，减少受理的延迟时间。
 * 生产者-消费者模式是多线程对资源读写比较典型的应用场景，也是使用最多的一种设计模式之一。
 *
 * 如何监控线程任务的生命周期？
 *
 * 当采用同步的方式对资源进行保护时，还需要注意同步的方式是否引起了锁交叉使用，锁在交叉使用的情况下会导致出现死锁的情况
 * 如何设计避免这种情况？
 * 并发读，并发写，并发读写
 * 读写锁分离设计，提高读场景明显多于写场景的程序效率
 *
 * 使用不可变对象的设计方式同样可以既高效又安全地解决多线程间数据冲突的问题
 * 将一个对象设计成不可变，任何线程都没有机会去修改它，这样就可以避免读-写 ，写-写 之间数据不一致的情况 java.lang.String
 *
 *  Future设计模式：在同步的API调用比较耗时的时候，可以先选择获取一个Future，这样调用者所在的线程不用陷入未知时长的阻塞中。
 *  使用Future可以使调用者立即返回进行其他任务的处理，在未来的某个时间在获取结果
 *
 *  Guarded Suspension 担保挂起设计模式，该设计模式是很多设计模式的基础，比如生产者消费者设计模式
 *  当某个对象的状态此刻不满足处理调用者请求的时候，选择将调用者正确的挂起，这样可以保证数据的正确性和完整性
 *
 *  线程上下文设计模式：
 *  通过线程保险箱设计实现了每一个线程的上下文，线程之间的上下文彼此独立，互相之前不受影响，确保了上下文只能被一个线程访问，
 *  从而避免了资源的竞争引起的冲突
 *
 *  Bulking 当某个对象此刻的状态不满足的时候，Bulking模式选择的是一种放弃的方案而不是挂起。
 *
 *  Latch设计模式，该设计模式旨在解决当所有涉及的线程完成各自的任务之后才能开始下一步动作的场景。
 *
 *
 *
 * */