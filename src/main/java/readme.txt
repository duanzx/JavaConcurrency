//解释以上各个容器的特点，实现原理
ConcurrentLinkedQueue:是一个基于链接节点的无界线程安全队列，采用先进先出的规则对节点进行排序，在队列的尾部添加新元素，在队列的头部获取元素。采用了wait-free算法来实现
内部结构：由head节点和tair节点组成，每个节点由节点元素和指向下一个节点的引用组成，节点与节点之间就是通过 下一个节点的引用next 关联起来，从而组成一张链表结构的队列
//如何实现并发？？？？？

入队列：1.将入队节点设置成当前队列尾节点的下一个节点。2.更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，反之则将入队节点设置成tail的next节点
在多个线程同时进行入队时候，如果有一个线程正在入队，那么它必须先获取tail节点，然后设置tail节点的下一个节点为入队节点，但这时候可能有另外一个线程插队了，此时队列的节点就回发生变化，这是当前线程
要暂停入队操作。然后重新获取tail节点。

让tail节点永远作为队列的尾节点，这样实现代码量非常少，而且逻辑非常清楚和易懂。
但是这么做有个缺点就是每次都需要使用循环CAS更新tail节点。
如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将 tail节点更新成尾节点，
而是当 tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长使用CAS更新tail节点的次数就会越少
，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，
因为从本质上来看它通过增加对volatile变量的读操作来减少了对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。

出队列：从队列里返回一个节点元素，并清空该节点对元素的引用，并不是每次出队时候都更新head几点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时候，才会更新head节点
首先获取头节点的元素，如果元素为空，表示另外一个线程已经进行了出队操作将节点元素取走了

情况1：tail节点的next节点不为空，那么插入后队列变成

旧的tail节点->旧tail节点的next节点->入队节点（新tail节点）

情况2：tail节点的next节点为空，那么插入后队列变成

tail节点->入队节点

ConcurrentHashMap:使用锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段的数据的时候，其他段的数据也能被其他线程访问。
ConcurrentHashMap是由Segment数组结构和HashEntry数组构成，Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。
一个ConcurrentHashMap里包含一个Segment数组。
Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。

Segment的get操作实现非常简单和高效。先经过一次再哈希，然后使用这个哈希值通过哈希运算定位到segment，再通过哈希算法定位到元素，
它的get方法里将要使用的共享变量都定义成volatile,定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值

Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。



ArrayBlockingQueue：一个基于数组结构的有界阻塞队列，按照先进先出原则对元素进行排序
LinkedBlockingQueue：一个基于链表结构的阻塞队列，吞吐量大于 ArrayBlockingQueue
PriorityBlockingQueue：一个具有优先级的无界阻塞队列
DelayQueue
SynchronousQueue：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。吞吐量大于LinkedBlockingQueue

CopyOnWriteArrayList


1、Runnable适合于多个相同程序代码线程去处理统一资源的情况，把虚拟的cpu（线程）同程序的代码，数据有效分离，较好体现面向对象的编程的思想

2、Runnable可以避免由于java的单继承机制带来的局限。可以再继承其他类的同时，还能实现多线程的功能。

3、Runnable能增加程序的健壮性。代码能够被多个线程共享。

合理利用线程池的好处：
1.降低资源消耗，通过重复利用已经创建的线程降低线程创建和销毁造成的消耗
2.提高响应速度，当任务到达时，不需要等到线程创建就能立即执行
3.提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控

要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：

    任务的性质：CPU密集型任务，IO密集型任务和混合型任务。
    任务的优先级：高，中和低。
    任务的执行时间：长，中和短。
    任务的依赖性：是否依赖其他系统资源，如数据库连接。

任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。

优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。

执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。

依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。

建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。
有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，
因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。
如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。
当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。


